{% extends "base.html" %}
{% block title %}Odontograma{% endblock %}
{% block subtitle %}{{ historia.paciente.nombres }} {{ historia.paciente.apellidos }} ({{ odontograma.tipo_odontograma }}){% endblock %} 
{% block content %}
<div class="row mt-2">
  <div class="col-3">
    <form>
      <label class="form-label w-100">
        Hallazgo clínico
        <select class="form-select" id="select">
          <option value="">-- Elegir --</option>
        </select>
      </label>
      <label>Vista previa</label><br>
      <canvas id="canvas-secondary" width="300" height="150"></canvas>
      <div class="btn-group w-100 ps-4 pe-4" role="group">
        <input type="radio" class="btn-check" name="color" autocomplete="off" id="color-azul" value="blue" checked />
        <label class="btn btn-outline-primary btn-sm" for="color-azul">Azul</label>
        <input type="radio" class="btn-check" name="color" autocomplete="off" id="color-rojo" value="red" />
        <label class="btn btn-outline-danger btn-sm" for="color-rojo">Rojo</label>
      </div>
      <button type="button" class="btn btn-primary mt-2 w-100" id="btn-save">Añadir hallazgo</button>
      <button type="button" class="btn btn-danger mt-1 w-100" id="btn-pop">Eliminar último hallazgo</button>
    </form>
    <label class="form-label w-100 mt-2">
      Especificaciones
      <textarea id="especificaciones" class="form-control" rows="2">{{ odontograma.especificaciones }}</textarea>
    </label>
      <label class="form-label w-100">
      Observaciones
      <textarea id="observaciones" class="form-control" rows="2">{{ odontograma.observaciones }}</textarea>
    </label>
    <button id='btn-save-all' class="btn btn-success mt-2 w-100">Guardar cambios y salir</button>
  </div>
  <div class="col-9 canvas-container">
    <canvas id="canvas-primary" width="1000" height="600"></canvas>
    <canvas id="canvas-selection" width="1000" height="600"></canvas>
  </div>
</div>
<style>
canvas {
  background-color: #eee;
}

#canvas-primary {
  z-index: 0;
}

#canvas-selection {
  background-color: transparent;
  z-index: 1;
}

div.canvas-container {
  position: relative;
  width: 800px;
  height: 600px;
}

div.canvas-container canvas {
  position: absolute;
  top: 0;
  left: 0;
}
</style>
<script>
'use strict';

/*
C-Diente
Clase que representa un diente dentro de una interfaz gráfica, con capacidades
para dibujarse, mostrar etiquetas, identificarse por número, y reflejar su estado
de selección o transformación (espejado, escala).
*/


class Diente {

  /*
  F-constructor
  Inicializa una instancia de la clase Diente con su imagen, posición, identificación,
  configuración de volteo horizontal/vertical, escala, y rectángulo de interacción.
  */

  constructor(image, x, y, id, lineId, flipH = false, flipV = false, scale = 8) {
    this.scale = scale;
    this.flipH = flipH;
    this.flipV = flipV;
    this.x = x;
    this.y = y;
    this.id = id;
    this.selected = false;
    this.lineId = lineId;
    this.dienteRect = {};
    this.tagY = y;

    // Determinar dimensiones base (asume que el nombre contiene "500" si es más ancho)
    this.originalWidth = image.width
    this.originalHeight = image.height;

    this.width = Math.round((this.originalWidth / 100) * scale);
    this.height = Math.round((this.originalHeight / 100) * scale);
    this.rectHeight = this.height
    this.image = image;
    this.tags = [];
  }

  /*
  F-getRect
  Devuelve las dimensiones actuales del área total ocupada por el diente,
  incluidas etiquetas y número.
  */
  getRect() {
    return {
      x: this.x,
      y: this.y,
      w: this.width,
      h: this.rectHeight
    };
  }

  /*
  F-getDienteRect
  Devuelve las dimensiones exactas de la imagen del diente (sin etiquetas ni número).
  */
  getDienteRect() {
    return this.dienteRect;
  }

  /*
  F-draw
  Dibuja el diente en el contexto de canvas proporcionado, con sus etiquetas,
  número identificador, imagen del diente y estado de selección.
  */
  draw(ctx) {
    this.tags = [];
    const tagsHeight = 20;
    const numberHeight = 20;

    let currentY = this.y;

    const drawTags = () => {
      ctx.save();
      ctx.fillStyle = "#fff";
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 1;
      ctx.fillRect(this.x, currentY, this.width, tagsHeight);
      ctx.strokeRect(this.x, currentY, this.width, tagsHeight);
      ctx.restore();
      this.tagY = currentY;
      currentY += tagsHeight + this.scale / 2;
    };

    const drawNum = () => {
      ctx.save();
      ctx.fillStyle = "#000";
      ctx.font = "16px monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(!this.id ? 'XX' : String(this.id), this.x + this.width / 2, currentY + numberHeight / 2);
      ctx.restore();
      currentY += numberHeight + this.scale / 2;
    };

    const drawDiente = () => {
      ctx.save();
      ctx.translate(this.x + this.width / 2, currentY + this.height / 2);
      ctx.scale(this.flipH ? -1 : 1, this.flipV ? -1 : 1);
      ctx.drawImage(this.image, -this.width / 2, -this.height / 2, this.width, this.height);
      this.dienteRect = {
        x: this.x,
        y: currentY,
        w: this.width,
        h: this.height
      };
      ctx.restore();
      currentY += this.height + (this.flipV ? this.scale : this.scale / 2);
    };

    if (this.flipV) {
      drawDiente();
      drawNum();
      drawTags();
    } else {
      drawTags();
      drawNum();
      drawDiente();
    }

    this.rectHeight = currentY - this.y;

    if (this.selected) {
      ctx.save();
      ctx.setLineDash([5, 3]);
      ctx.strokeStyle = "black";
      ctx.lineWidth = 1;
      ctx.strokeRect(this.x - this.scale / 2, this.y - this.scale / 2, this.width + this.scale, currentY - this.y + this.scale/2);
      ctx.restore();
    }
  }

  /*
  F-addTag
  Agrega una etiqueta de texto y color al diente.
  */
  addTag(tag, color) {
    this.tags.push([tag, color]);
  }

  /*
  F-drawTags
  Dibuja todas las etiquetas asociadas al diente encima del mismo.
  */

  drawTags(ctx) {
    const fontSize = 12;
    const y = this.tagY + fontSize/2; // posición encima del diente
    let x = this.x + 4;

    ctx.font = `${fontSize}px monospace`;
    ctx.textBaseline = 'top';

    for (const [texto, color] of this.tags) {
      ctx.fillStyle = color;
      ctx.fillText(texto, x, y);
      x += ctx.measureText(texto).width + this.scale / 2; // agregar espacio entre palabras
    }
  }
}

const canvasPrimary = document.getElementById('canvas-primary'); 
const ctxPrimary = canvasPrimary.getContext('2d');
const canvasSelection = document.getElementById('canvas-selection'); 
const ctxSelection = canvasSelection.getContext('2d');
const canvasSecondary = document.getElementById('canvas-secondary');
const ctxSecondary = canvasSecondary.getContext('2d');
const select = document.getElementById('select');
const especificaciones = document.getElementById('especificaciones');
const observaciones = document.getElementById('observaciones');

let dientes = [];
let dientesSecondary = [];
let selectionOrigin = null;
let selectedDientesIndexes = [];
let tipoHallazgo = null;
let currentHallazgo = null;
let currentColor = 'blue';
let hallazgosClinicos = JSON.parse({{ odontograma.hallazgos_clinicos|tojson }});

const hallazgosClinicosFns = {
  simple: {

    /*
    F-CoronaMetalica
    Dibuja una corona metálica representada como un rectángulo que ocupa la mitad inferior del diente (o superior si flipV está activo). 
    Añade la etiqueta 'CM' al diente.
    */
    'Corona metálica': (ctx, diente, color) => {
      diente.addTag('CM', color);
      const rect = diente.getDienteRect();
      // Dibujar un rectangulo de h/2 x w en la parte inferior del diente
      // o superior si flipV es verdadero

      // Determinar la posición del rectángulo según la orientación
      const x = rect.x;
      const y = diente.flipV ? rect.y : rect.y + rect.h / 2;

      ctx.save();
      ctx.strokeStyle = color; // Color del borde
      ctx.lineWidth = 3;
      ctx.strokeRect(x, y, rect.w, rect.h / 2);
      ctx.restore();
    },
    /*
      F-CariesDentina
      Dibuja una pequeña lesión rectangular en la dentina, centrada en la parte inferior del diente (o superior si flipV). 
      Añade la etiqueta 'CD'.
    */
    'Lesión de caries a nivel de la dentina': (ctx, diente, color) => {
      diente.addTag('CD', color);
      const rect = diente.getDienteRect();
      // Dibujar un pequeño rectangulo en la parte central inferior del diente
      // o superior si flipV es verdadero

      const rectWidth = rect.w * 0.4;
      const rectHeight = rect.h * 0.15;

      const x = rect.x + (rect.w - rectWidth) / 2;
      const y = diente.flipV
        ? rect.y + rect.h / 4 - rectHeight / 2 // parte superior
        : rect.y + 3 * rect.h / 4 - rectHeight / 2; // parte inferior

      ctx.save();
      ctx.fillStyle = color;
      ctx.fillRect(x, y, rectWidth, rectHeight);
      ctx.restore();
    },
    /*
      F-Impactacion
      Solo añade la etiqueta 'I' para indicar que el diente está impactado. No realiza ningún dibujo.
    */
    'Impactación': (ctx, diente, color) => {
      diente.addTag('I', color);
    },
    /*
      F-PiezaAusente
      Representa una pieza dentaria ausente mediante una "X" dibujada sobre el diente. 
      Añade la etiqueta 'DEX'.
    */
    'Pieza dentaria ausente': (ctx, diente, color) => {
      diente.addTag('DEX', color);
      const rect = diente.getDienteRect();
      // Dibujar una X en el diente
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 3;

      // Línea diagonal de esquina a esquina
      ctx.beginPath();
      ctx.moveTo(rect.x, rect.y);
      ctx.lineTo(rect.x + rect.w, rect.y + rect.h);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(rect.x + rect.w, rect.y);
      ctx.lineTo(rect.x, rect.y + rect.h);
      ctx.stroke();

      ctx.restore();
    },
    /*
      F-PigmentacionEsmalte
      Solo añade la etiqueta 'PE' para indicar pigmentación del esmalte. No realiza dibujo.
    */
    'Pigmentación del esmalte': (ctx, diente, color) => {
      diente.addTag('PE', color);
    },
    /*
      F-RestauracionDefinitiva
      Dibuja un rectángulo relleno en la raíz del diente para indicar restauración definitiva con resina.
      Añade la etiqueta 'R'.
    */
    'Restauración definitiva con resina': (ctx, diente, color) => {
      diente.addTag('R', color);
      // Dibujar un cuadrado de lineas en la raiz
      const r = diente.getDienteRect();
      const y1 = diente.flipV ? r.y + r.h / 8 : r.y + 5 * r.h / 8;

      ctx.save();
      ctx.fillStyle = color;
      ctx.fillRect(r.x + r.w / 5, y1, 3 * r.w / 5, r.h / 4);
      ctx.restore();
    },
    /*
      F-RestauracionTemporal
      Dibuja un rectángulo vacío (solo contorno) en la raíz del diente para representar una restauración temporal.
      Añade la etiqueta 'R'.
    */
    'Restauración temporal': (ctx, diente, color) => {
      diente.addTag('R', color);
      // Dibujar un cuadrado con color en la raiz
      const r = diente.getDienteRect();
      const y1 = diente.flipV ? r.y + r.h / 8 : r.y + 5 * r.h / 8;

      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 3;
      ctx.strokeRect(r.x + r.w / 5, y1, 3 * r.w / 5, r.h / 4);
      ctx.restore();
    },
    /*
      F-Sellante
      Dibuja una cruz (una línea vertical y otra horizontal) en la raíz del diente para indicar presencia de sellante.
      Añade la etiqueta 'S'.
    */
    'Sellante': (ctx, diente, color) => {
      diente.addTag('S', color);
      // Dibujar una cruz en la raiz
      const r = diente.getDienteRect();
      const y1 = diente.flipV ? r.y + r.h / 8 : r.y + 5 * r.h / 8;
      const y2 = diente.flipV ? r.y + 3 * r.h / 8 : r.y + 7 * r.h / 8;
      const y3 = diente.flipV ? r.y + r.h / 4 : r.y + 3 * r.h / 4;

      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 3;

      ctx.beginPath();
      ctx.moveTo(r.x + r.w / 2, y1);
      ctx.lineTo(r.x + r.w / 2, y2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(r.x + r.w / 5, y3);
      ctx.lineTo(r.x + 4 * r.w / 5, y3);
      ctx.stroke();

      ctx.restore();
    },
    /*
      F-EspigoMunon
      Dibuja un rectángulo en la raíz y una línea vertical hacia la corona para representar espigo-muñón.
      No añade etiqueta.
    */
    'Espigo - muñón': (ctx, diente, color) => {
      // Dibujar un cuadrado en la raiz y una linea hacia arriba
      const r = diente.getDienteRect();
      const y1 = diente.flipV ? r.y + r.h / 8 : r.y + 5 * r.h / 8;
      const y2 = diente.flipV ? r.y + 3 * r.h / 8 : r.y + 5 * r.h / 8;
      const y3 = diente.flipV ? r.y + r.h : r.y;

      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 3;

      ctx.strokeRect(r.x + r.w / 5, y1, 3 * r.w / 5, r.h / 4);
      ctx.beginPath();
      ctx.moveTo(r.x + r.w / 2, y2);
      ctx.lineTo(r.x + r.w / 2, y3);
      ctx.stroke();

      ctx.restore();
    },
    /*
      F-TratamientoConducto
      Dibuja una línea vertical desde la raíz hacia la corona del diente para indicar tratamiento de conducto.
      Añade la etiqueta 'TC'.
    */
    'Tratamiento de conducto': (ctx, diente, color) => {
      // dibujar una linea de la raiz hacia arriba
      diente.addTag('TC', color);
      const r = diente.getDienteRect();
      const y1 = diente.flipV ? r.y + r.h / 4 : r.y + 3 * r.h / 4;
      const y2 = diente.flipV ? r.y + r.h : r.y;
      
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 3;

      ctx.beginPath();
      ctx.moveTo(r.x + r.w / 2, y1);
      ctx.lineTo(r.x + r.w / 2, y2);
      ctx.stroke();

      ctx.restore();
    },
    /*
      F-ImplanteDental
      Solo añade la etiqueta 'IMP' para indicar que el diente es un implante. No realiza dibujo.
    */
    'Implante dental': (ctx, diente, color) => {
      // Solo añadir tag
      diente.addTag('IMP', color);
    },
    /*
      F-MovilidadPatologica
      Solo añade la etiqueta 'M1' para indicar que el diente tiene movilidad patológica. No realiza dibujo.
    */
    'Movilidad patológica': (ctx, diente, color) => {
      // Solo añadir tag
      diente.addTag('M1', color);
    },
  },
  doble: {
    /*
      F-Fusion
      Representa una fusión dentaria dibujando dos óvalos (uno sobre cada diente) conectados por una línea. 
      Los óvalos se ubican por encima de los dientes, o por debajo si flipV está activo.
    */
    'Fusión': (ctx, diente1, diente2, color) => {
      // Dibujar dos ovalos arriba de los dientes (o abajo si flipV = true)
      // tal que los ovalos se conecten

      const r1 = diente1.getDienteRect();
      const r2 = diente2.getDienteRect();

      const ovalWidth = Math.min(r1.w, r2.w) * 1;
      const ovalHeight = 14;

      const y = diente1.flipV
        ? Math.max(r1.y + r1.h, r2.y + r2.h) + 10 // debajo
        : Math.min(r1.y, r2.y) - ovalHeight - 2; // encima

      const centerX1 = r1.x + r1.w / 2;
      const centerX2 = r2.x + r2.w / 2;

      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 3;

      // Dibujar óvalo sobre diente1
      ctx.beginPath();
      ctx.ellipse(centerX1, y, ovalWidth / 2, ovalHeight / 2, 0, 0, 2 * Math.PI);
      ctx.stroke();

      // Dibujar óvalo sobre diente2
      ctx.beginPath();
      ctx.ellipse(centerX2, y, ovalWidth / 2, ovalHeight / 2, 0, 0, 2 * Math.PI);
      ctx.stroke();

      // Línea entre ambos óvalos para conexión visual
      ctx.beginPath();
      ctx.moveTo(centerX1 + ovalWidth / 2, y);
      ctx.lineTo(centerX2 - ovalWidth / 2, y);
      ctx.stroke();

      ctx.restore();
    },
    /*
      F-Diastema
      Representa un diastema (separación entre dientes) dibujando un arco curvado hacia afuera a la derecha del primer diente 
      y otro hacia afuera a la izquierda del segundo diente. 
      Se dibujan en la parte media vertical del diente, ya sea superior o inferior según flipV.
    */
    'Diastema': (ctx, diente1, diente2, color) => {
      // Dibujar dos arcos, uno en diente1 a la derecha y otro en diente2
      // a la izquierda con altura h/2 en la parte inferior (o superior si flipV = true)

      const r1 = diente1.getDienteRect();
      const r2 = diente2.getDienteRect();

      const arcRadius = (r1.h / 2); // altura aproximada del arco

      const isFlip = diente1.flipV || diente2.flipV;

      const yStart1 = isFlip ? r1.y + r1.h / 2 : r1.y + r1.h / 2;
      const yEnd1   = isFlip ? r1.y : r1.y + r1.h;

      const yStart2 = isFlip ? r2.y + r2.h / 2 : r2.y + r2.h / 2;
      const yEnd2   = isFlip ? r2.y : r2.y + r2.h;

      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 3;
      const offsetX = 26

      // Arco en diente1 (lado derecho)
      ctx.beginPath();
      ctx.arc(r1.x + r1.w - offsetX, (yStart1 + yEnd1) / 2, arcRadius,
        Math.PI * 0.25, Math.PI * 1.75, true);
      ctx.stroke();

      // Arco en diente2 (lado izquierdo)
      ctx.beginPath();
      ctx.arc(r2.x + offsetX, (yStart2 + yEnd2) / 2, arcRadius,
        Math.PI * 0.75, Math.PI * 1.25, false);
      ctx.stroke();

      ctx.restore();
    },
  },
  multiple: {
    /*
      F-AparatoOdontologico
      Representa un aparato odontológico fijo, dibujando una línea horizontal que conecta los dientes seleccionados,
      con pequeños rectángulos en ambos extremos. La línea se dibuja por debajo o por encima de los dientes según flipV.
    */
    'Aparato odontológico': (ctx, diente1, diente2, color) => {
      // Línea por debajo de los dientes con rectangulos en sus puntos extremos
      const r1 = diente1.getDienteRect();
      const r2 = diente2.getDienteRect();
      const y = diente1.flipV ? r1.y - 8 : r1.y + r1.h + 8;
      const offsetY = -4
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 3;

      ctx.beginPath();
      ctx.moveTo(r1.x, y);
      ctx.lineTo(r2.x + r2.w, y);
      ctx.stroke();

      ctx.fillStyle = color;
      ctx.fillRect(r1.x, y + offsetY, 8, 8);
      ctx.fillRect(r2.x + r2.w - 8, y + offsetY, 8, 8);

      ctx.restore();
    },
    /*
      F-EdentuloTotal
      Representa una zona edéntula (sin dientes) total, dibujando una sola línea que atraviesa horizontalmente los dientes seleccionados,
      a una altura correspondiente a la base del diente o su corona según flipV.
    */
    'Edéntulo total': (ctx, diente1, diente2, color) => {
      // Línea que cruza los dientes
      const r1 = diente1.getDienteRect();
      const r2 = diente2.getDienteRect();
      const y = diente1.flipV ? r1.y + r1.h / 4 : r1.y + 3 * r1.h / 4;
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 3;

      ctx.beginPath();
      ctx.moveTo(r1.x, y);
      ctx.lineTo(r2.x + r2.w, y);
      ctx.stroke();

      ctx.restore();
    },
    /*
      F-ProtesisParcialFija
      Representa una prótesis parcial fija dibujando una línea superior entre los dientes, 
      comenzando y terminando en el centro de cada uno, y descendiendo en forma de dos líneas verticales.
      Se adapta al lado superior o inferior del diente dependiendo de flipV.
    */

    'Prótesis parcial fija': (ctx, diente1, diente2, color) => {
      // Linea arriba de los diente que empieze y termine en el centro
      // con dos lineas para abajo
      const r1 = diente1.getDienteRect();
      const r2 = diente2.getDienteRect();
      const y = diente1.flipV ? r1.y + r1.h : r1.y;
      const offsetY = diente1.flipV ? 6 : -6;
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 3;

      ctx.beginPath();
      ctx.moveTo(r1.x + r1.w / 2, y + offsetY);
      ctx.lineTo(r2.x + r2.w / 2, y + offsetY);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(r1.x + r1.w / 2, y + offsetY);
      ctx.lineTo(r1.x + r1.w / 2, y);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(r2.x + r2.w / 2, y + offsetY);
      ctx.lineTo(r2.x + r2.w / 2, y);
      ctx.stroke();

      ctx.restore();
    },
    /*
      F-ProtesisCompleta
      Representa una prótesis completa dibujando dos líneas horizontales conectadas por los centros de los dientes.
      Se dibuja en la parte superior o inferior del diente según flipV.
    */
    'Prótesis completa': (ctx, diente1, diente2, color) => {
      // Linea arriba de los diente que empieze y termine en el centro
      // con dos lineas para abajo
      const r1 = diente1.getDienteRect();
      const r2 = diente2.getDienteRect();
      const y = diente1.flipV ? r1.y + r1.h : r1.y;
      const offsetY = diente1.flipV ? 6 : -6;
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;

      ctx.beginPath();
      ctx.moveTo(r1.x + r1.w / 2, y + offsetY);
      ctx.lineTo(r2.x + r2.w / 2, y + offsetY);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(r1.x + r1.w / 2, y + offsetY / 2);
      ctx.lineTo(r2.x + r2.w / 2, y + offsetY / 2);
      ctx.stroke();

      ctx.restore();
    },
  }
};


/*
  F-getFunc
  Recupera la función correspondiente a un hallazgo clínico específico en base a su tipo (simple, doble, múltiple) 
  y nombre (como "Corona metálica", "Fusión", etc.). Se utiliza para acceder dinámicamente a las funciones de dibujo
  asociadas a cada condición dental.
*/
function getFunc(tipo, nombre) {
  return hallazgosClinicosFns[tipo][nombre];
}

/*
  F-createDientes
  Crea y posiciona objetos "Diente" para representar la dentadura completa (superior e inferior, temporal y permanente).
  Cada grupo de dientes es generado con una forma específica dependiendo de su tipo anatómico y ubicación (simple, doble, etc.).
  Además, considera la orientación (superior/inferior) y si el diente se encuentra a la derecha o izquierda de la línea media.
*/
function createDientes(images) {
  dientes = [];
  const offsetX = 130;
  let currentX = 0 + offsetX, currentY = 20;
  let dienteIds = [];
  for (let i = 18; i >= 11; i--) dienteIds.push(i);
  for (let i = 21; i <= 28; i++) dienteIds.push(i);
  dienteIds.forEach((id, index) => {
    let shape = 'triple';
    if (id === 15 || id == 25) shape = 'solo';
    else if (id === 14 || id === 24) shape = 'doble-punteado';
    else if (id <= 13 || (21 <= id && id <= 23)) shape = 'simple';
    const diente = new Diente(images[shape], currentX, currentY, id, 0, index > dienteIds.length / 2);
    dientes.push(diente);
    currentX += diente.width + 10;
  });

  currentX = 150 + offsetX, currentY = 160;
  dienteIds = [];
  for (let i = 55; i >= 51; i--) dienteIds.push(i);
  for (let i = 61; i <= 65; i++) dienteIds.push(i);
  dienteIds.forEach((id, index) => {
    let shape = 'triple';
    if (id === 54 || id == 64) shape = 'triple-3';
    else if (id <= 53|| (61 <= id && id <= 63)) shape = 'simple';
    const diente = new Diente(images[shape], currentX, currentY, id, 1, index > dienteIds.length / 2);
    dientes.push(diente);
    currentX += diente.width + 10;
  });

  currentX = 150 + offsetX, currentY = 300;
  dienteIds = [];
  for (let i = 85; i >= 81; i--) dienteIds.push(i);
  for (let i = 71; i <= 75; i++) dienteIds.push(i);
  dienteIds.forEach((id, index) => {
    let shape = 'doble-separado-5';
    if (id === 84 || id == 74) shape = 'doble-separado';
    else if (id % 10 <= 3) shape = 'simple';
    const diente = new Diente(images[shape], currentX, currentY, id, 2, index > dienteIds.length / 2, true);
    dientes.push(diente);
    currentX += diente.width + 10;
  });

  currentX = 0 + offsetX, currentY = 440;
  dienteIds = [];
  for (let i = 38; i >= 31; i--) dienteIds.push(i);
  for (let i = 41; i <= 48; i++) dienteIds.push(i);
  dienteIds.forEach((id, index) => {
    let shape = 'doble';
    if (id % 10 == 6) shape = 'doble-5';
    else if (id % 10 == 4 || id % 10 == 5) shape = 'solo';
    else if (id % 10 <= 3) shape = 'simple';
    const diente = new Diente(images[shape], currentX, currentY, id, 3, index > dienteIds.length / 2, true);
    dientes.push(diente);
    currentX += diente.width + 10;
  });
}
/*
  F-drawPrimaryCanvas
  Limpia y dibuja el canvas principal (`canvasPrimary`) con los dientes base,
  luego recorre la lista de hallazgos clínicos (`hallazgosClinicos`) para renderizar 
  visualmente cada uno (según su tipo: simple, doble o múltiple) y finalmente dibuja las etiquetas.
*/
function drawPrimaryCanvas() {
  ctxPrimary.clearRect(0, 0, canvasPrimary.width, canvasPrimary.height);
  dientes.forEach(diente => diente.draw(ctxPrimary));

  hallazgosClinicos.forEach(args => {
    if (args.length == 3) {
      let func = getFunc('simple', args[0]);
      if (func) func(ctxPrimary, dientes[args[1]], args[2]);
    } else {
      let func = getFunc('doble', args[0]);
      if (func) func(ctxPrimary, dientes[args[1]], dientes[args[2]], args[3]);
      func = getFunc('multiple', args[0]);
      if (func) func(ctxPrimary, dientes[args[1]], dientes[args[2]], args[3]);
    }
  });

  dientes.forEach(diente => diente.drawTags(ctxPrimary));
}
/*
  F-preloadImages
  Carga imágenes SVG de dientes desde el servidor y las convierte en objetos `Image`,
  devolviendo una promesa que resuelve en un diccionario indexado por nombre.
  Se usa para cargar las formas necesarias antes de renderizar.
*/
function preloadImages(shapeList) {
  const images = {};
  const loadPromises = shapeList.map(shape => {
    return fetch(`/static/dientes/${shape}.svg`)
      .then(res => res.text())
      .then(svgText => {
        return new Promise((resolve) => {
          const blob = new Blob([svgText], { type: "image/svg+xml;charset=utf-8" });
          const url = URL.createObjectURL(blob);
          const img = new Image();
          img.onload = () => {
            URL.revokeObjectURL(url);
            images[shape] = img;
            resolve();
          };
          img.src = url;
        });
      });
  });

  return Promise.all(loadPromises).then(() => images);
}
/*
  F-drawSelectionCanvas
  Dibuja el área de selección rectangular durante una operación de clic y arrastre 
  del usuario sobre el canvas de selección (`canvasSelection`), resaltando con un borde punteado.
*/
function drawSelectionCanvas(e) {
  // Limpia el canvas (transparente)
  ctxSelection.clearRect(0, 0, canvasSelection.width, canvasSelection.height);

  if (selectionOrigin) {
    const x = selectionOrigin.x;
    const y = selectionOrigin.y;
    const width = e.offsetX - x;
    const height = e.offsetY - y;

    ctxSelection.setLineDash([4, 2]); // Opcional: línea punteada
    ctxSelection.beginPath();
    ctxSelection.strokeStyle = "#007bff"; // Azul
    ctxSelection.rect(x, y, width, height);
    ctxSelection.lineWidth = 1;
    ctxSelection.fillStyle = "rgba(0, 123, 255, 0.2)";
    ctxSelection.fillRect(x, y, width, height);
    ctxSelection.stroke();
    ctxSelection.setLineDash([]); // Restablecer patrón de línea
  }
}
/*
  F-rectsCollide
  Determina si dos rectángulos se superponen en el espacio 2D. 
  Se usa para saber si un diente ha sido seleccionado por un área rectangular.
*/
function rectsCollide(rectA, rectB) {
  return !(
    rectA.x + rectA.w <= rectB.x || // A está completamente a la izquierda de B
    rectA.x >= rectB.x + rectB.w || // A está completamente a la derecha de B
    rectA.y + rectA.h <= rectB.y || // A está completamente arriba de B
    rectA.y >= rectB.y + rectB.h    // A está completamente debajo de B
  );
}
/*
  F-updateLeftPanel
  Actualiza dinámicamente las opciones del panel izquierdo (`select`) dependiendo del tipo 
  de hallazgo clínico actual (`tipoHallazgo`) y genera una vista previa en `dientesSecondary`.
*/
function updateLeftPanel(images) {
  select.innerHTML = '<option value="">-- Elegir --</option>';
  currentHallazgo = null;

  if (!tipoHallazgo) {
    dientesSecondary = [];
    drawSecondaryCanvas();
    return;
  }

  Object.keys(hallazgosClinicosFns[tipoHallazgo]).forEach(key => {
    const option = document.createElement('option');
    option.value = key;
    option.textContent = key;
    select.appendChild(option);
  });

  if (tipoHallazgo == 'doble') {
    Object.keys(hallazgosClinicosFns['multiple']).forEach(key => {
      const option = document.createElement('option');
      option.value = key;
      option.textContent = key;
      select.appendChild(option);
    });
  }

  const length = Object.keys(hallazgosClinicosFns).indexOf(tipoHallazgo) + 1;
  dientesSecondary = []
  let currentX = 0, currentY = 20;

  switch(tipoHallazgo) {
    case 'simple':
      currentX = 130;
      break;
    case 'doble':
      currentX = 100;
      break;
    default:
      currentX = 80;
      break;
  }

  let dienteIds = [];
  for (let i = 0; i < length; i++) dienteIds.push(null);
  dienteIds.forEach((id, index) => {
    if (length === 3 && index === 1) {
      currentX += 50;
      return;
    }
    const diente = new Diente(
      dientes[selectedDientesIndexes[Math.min(index, 1)]].image,
      currentX, currentY, id, 0, false,
      dientes[selectedDientesIndexes[Math.min(index, 1)]].flipV
    );
    dientesSecondary.push(diente);
    currentX += diente.width + 10;
  });

  drawSecondaryCanvas();
}
/*
  F-drawSecondaryCanvas
  Dibuja los dientes secundarios (`dientesSecondary`) para la vista previa de un hallazgo.
  Si hay un hallazgo seleccionado (`currentHallazgo`), lo renderiza sobre los dientes.
*/
function drawSecondaryCanvas() {
  ctxSecondary.clearRect(0, 0, canvasSecondary.width, canvasSecondary.height);
  dientesSecondary.forEach(diente => diente.draw(ctxSecondary));
  if (tipoHallazgo === 'multiple') {
    ctxSecondary.font = "bold 16px monospace";
    ctxSecondary.fillStyle = 'black';
    ctxSecondary.fillText('...', 135, dientesSecondary[0].flipV ? 35 : 100);
  }
  if (dientesSecondary.length > 0 && currentHallazgo) {
    if (tipoHallazgo === 'simple') getFunc(tipoHallazgo, currentHallazgo)(ctxSecondary, dientesSecondary[0], currentColor);
    else getFunc(tipoHallazgo, currentHallazgo)(ctxSecondary, dientesSecondary[0], dientesSecondary[1], currentColor);
  }
  dientesSecondary.forEach(diente => diente.drawTags(ctxSecondary));
}

preloadImages(['doble-5', 'doble-punteado', 'doble-separado-5',
    'doble-separado', 'doble', 'simple', 'solo', 'triple', 'triple-3'
]).then(images => {
  createDientes(images);
  drawPrimaryCanvas();
  /*
  F-onMouseDown (canvasSelection)
  Captura el punto inicial de una selección rectangular del usuario.
  */
  canvasSelection.onmousedown = (e) => {
    selectionOrigin = {x: e.offsetX, y: e.offsetY};
  };
  /*
  F-onMouseMove (canvasSelection)
  Dibuja dinámicamente el área de selección mientras el usuario mueve el mouse.
  */
  canvasSelection.onmousemove = (e) => {
    if (selectionOrigin) drawSelectionCanvas(e);
  };
  /*
  F-onMouseUp (canvasSelection)
  Finaliza la selección de dientes y determina si se trata de un hallazgo simple, doble o múltiple.
  Luego actualiza el canvas y el panel izquierdo en base a la selección.
  */
  canvasSelection.onmouseup = (e) => {
    if (!selectionOrigin) {
      selectionOrigin = null;
      drawSelectionCanvas(e);
      drawPrimaryCanvas();
      updateLeftPanel(images);
      return;
    }

    const selectionRect = {
      x: Math.min(selectionOrigin.x, e.offsetX),
      y: Math.min(selectionOrigin.y, e.offsetY),
      w: Math.abs(e.offsetX - selectionOrigin.x),
      h: Math.abs(e.offsetY - selectionOrigin.y),
    }

    let lineSelection = null;
    selectedDientesIndexes = []

    dientes.forEach((diente, index) => {
      diente.selected = rectsCollide(selectionRect, diente.getRect()) && (lineSelection == null || lineSelection == diente.lineId);
      if (diente.selected) {
        if (lineSelection === null) lineSelection = diente.lineId;
        selectedDientesIndexes.push(index);
      }
    });

    if (selectedDientesIndexes.length == 0) {
      tipoHallazgo = null;
    } else if (selectedDientesIndexes.length == 1) {
      tipoHallazgo = 'simple';
    } else {
      tipoHallazgo = selectedDientesIndexes.length == 2 ? 'doble' : 'multiple';
      selectedDientesIndexes = [selectedDientesIndexes[0], selectedDientesIndexes[selectedDientesIndexes.length - 1]];
    }

    selectionOrigin = null;
    drawSelectionCanvas(e);
    drawPrimaryCanvas();
    updateLeftPanel(images);
  };
  /*
  F-selectChange
  Controla el cambio de selección de hallazgo en el panel izquierdo.
  Actualiza el hallazgo actual (`currentHallazgo`) y redibuja la vista previa.
  */
  select.addEventListener('change',() => {
    if (!tipoHallazgo || !select.value) {
      currentHallazgo = null;
    } else {
      currentHallazgo = select.value;
    }
    drawSecondaryCanvas();
  });

  /*
  F-colorChange
  Actualiza el color actual seleccionado (`currentColor`) para el hallazgo clínico.
  Redibuja la vista previa con el nuevo color.
  */
  document.getElementsByName('color').forEach(radio => {
    radio.addEventListener('change', () => {
      if (radio.checked) {
        currentColor = radio.value;
        drawSecondaryCanvas();
      }
    });
  });
  /*
  F-onSaveClick
  Guarda el hallazgo clínico actual (si hay selección) en la lista `hallazgosClinicos`
  y actualiza la vista.
  */
  document.getElementById('btn-save').addEventListener('click', () => {
    if (!tipoHallazgo || !currentHallazgo) return;
    hallazgosClinicos.push([currentHallazgo, ...selectedDientesIndexes, currentColor]);
    tipoHallazgo = null;
    updateLeftPanel(images);
    dientes.forEach(diente => diente.selected = false);
    drawPrimaryCanvas();
  });
  /*
  F-onPopClick
  Elimina el último hallazgo clínico añadido y actualiza la vista.
  */
  document.getElementById('btn-pop').addEventListener('click', () => {
    tipoHallazgo = null;
    if (hallazgosClinicos.length > 0) hallazgosClinicos.pop();
    updateLeftPanel(images);
    dientes.forEach(diente => diente.selected = false);
    drawPrimaryCanvas();
  });
  /*
  F-onSaveAllClick
  Envía todos los hallazgos clínicos al servidor usando `fetch` con método POST.
  Incluye también especificaciones y observaciones.
  */
  document.getElementById('btn-save-all').addEventListener('click', (e) => {
    const csrf_token = "{{ csrf_token() }}";
    const url = window.location.href;
    fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': csrf_token
      },
      body: JSON.stringify({
        'hallazgos_clinicos': hallazgosClinicos,
        'especificaciones': especificaciones.value,
        'observaciones': observaciones.value,
      })
    })
    .then(response => {
      // Verifica si la respuesta HTTP fue exitosa (código 2xx)
      if (!response.ok) {
        return response.json().then(errorData => {
          throw new Error(errorData.message || "Error desconocido del servidor.");
        });
      }
      return response.json();
    })
    .then(result => {
      console.log("Éxito al guardar");
      window.location.href = '/historia/{{ historia.historia_id }}';
    })
    .catch(error => {
      console.error("Error en la solicitud fetch o del servidor:", error.message);
      alert("Error al guardar hallazgos: " + error.message);
    });
  });
});
</script>
{% endblock %}